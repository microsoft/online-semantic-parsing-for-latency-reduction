# Copyright (c) Microsoft Corporation.
# Licensed under the MIT license.
"""An interface layer that serves in between the actions generated from the graph oracle
and the actions in the modeling:
original action sequence (from oracle) -> interface -> action sequence to be conceived by the model
                                                      (+ any state information at each token step)
action sequence generated by the model -> interface -> state information at each token step

It is inherited from the graph state machine, with possible refactoring or reformation of the
detailed actions and steps depending on the modeling.

This one deals with copying tokens from the source, through a COPY action with source pointers.

Usage:
- At training time, the actions (input and output to the decoder) along with any state information are generated in
preprocessing.
- At decoding time, the interface runs with the model generated (possibly reformulated) action sequence, and
generate any state information on the fly.
"""
from copy import deepcopy
from itertools import product
import os
import re
from typing import List, Tuple, Callable

import numpy as np
from fairseq.tokenizer import tokenize_line
from tqdm import tqdm

from dataflow.core.constants import SpecialStrings as SrcSpecialStrings
from calflow_parsing.calflow_machine import CalFlowMachine, peel_pointer, join_action_pointer
from fairseq_gap.constants import SpecialSymbols


# matching regex for the copy action
copy_regex = re.compile(rf'{SpecialSymbols.COPY}\((.*)\)')


class CalFlowActionsSrcCopyInterface(CalFlowMachine):

    # canonical actions without the detailed node/edge labels and action properties (e.g. arc pointer value)
    # NOTE 'CLOSE' action is not explicitly written in the data
    canonical_actions = CalFlowMachine.canonical_actions + ['COPY']

    # configuration
    copy_only_string = True    # whether to only consider copying within the string
    tgt_input_original = False    # whether to use original token for target input instead of the COPY action
    # NOTE this requires tgt and src share some embeddings

    def __init__(self, src_tokens=None):
        super().__init__()

        # source tokens
        self.src_tokens = src_tokens

        # model decoding input and output
        self.actions_nopos_in = []
        self.actions_nopos_out = []
        self.actions_pos = []
        self.actions_src_pos = []

        # general state information
        # see `def get_states(self)`

        # step counter
        self.action_step = 0     # model decoding step

    def __deepcopy__(self, memo):
        """
        Manual deep copy of the machine.
        """
        cls = self.__class__
        result = cls.__new__(cls)
        memo[id(self)] = result
        for k, v in self.__dict__.items():
            setattr(result, k, deepcopy(v, memo))
        return result

    @classmethod
    def reset_config(cls, *, copy_only_string, tgt_input_original):
        # reset the class configuration
        cls.copy_only_string = copy_only_string
        cls.tgt_input_original = tgt_input_original

    @classmethod
    def find_matched_positions(cls, src_tokens: List[str], action: str) -> List[int]:
        """Find positions in the source token sequence where an action token is exactly matched.

        Args:
            src_tokens (List[str]): [description]
            action (str): [description]

        Returns:
            List[int]: [description]
        """
        # do not copy the quotation marks as they are special tokens for strings
        if action in [SpecialSymbols.STRING_MARK, SpecialSymbols.STRING_MARK_END]:
            return []

        matched_idxs = [i for i, tok in enumerate(src_tokens) if tok == action]

        return matched_idxs

    @classmethod
    def get_src_copy_strings(cls, src_tokens, string_actions: List[str]) -> Tuple[List[str], List[int]]:
        """Get the copy with src pointer actions to find the match of a span of tokens. When there is
        no exact match of the whole span, find the match with the maximum number of matches and tighter
        matched positions for the span.

        NOTE when the span is a single token, the returned match is the fist one following the src tokens.

        Args:
            src_tokens ([type]): [description]
            string_actions (List[str]): [description]

        Returns:
            Tuple[List[str], List[int]]: [description]
        """
        # assert string_actions, 'input "string_actions" should not be an empty list or None'

        # NOTE for TreeDST above is not true for at least 1 example -> comment the assert above

        assert isinstance(string_actions, list), 'input "string_actions" must be a list'
        string_len = len(string_actions)
        for i in range(len(src_tokens) - string_len):
            if string_actions == src_tokens[i:(i + string_len)]:
                # span matched, return the COPY actions with src pointers
                # copy positions
                copy_pos = list(range(i, i + string_len))
                copy_actions = [f'{SpecialSymbols.COPY}({x})' for x in copy_pos]
                return copy_actions, copy_pos

        # not finding the whole span match
        matched_idxs_all = [cls.find_matched_positions(src_tokens, act) for act in string_actions]
        # get all the possible combination of matches
        # replace empty list [] with [None] so that we can use the 'product' function
        matched_idxs_all = [idxs if idxs else [None] for idxs in matched_idxs_all]
        possible_match_positions = list(product(*matched_idxs_all))
        possible_match_scores = []
        for match_pos in possible_match_positions:
            if all_pos := list(filter(lambda x: x is not None, match_pos)):
                match_score = np.diff(all_pos)
            else:
                match_score = np.array([])
            # score for a possible match sequence:
            # pick the one span matching with max number of matches and min average pos difference (a tighter span)
            # `len(src_tokens)**2` is larger than the max score computed as the square of the average pos difference
            match_score = ((match_score - 1)**2).mean() if match_score.size >= 1 else float('inf')
            match_score -= len(all_pos) * len(src_tokens)**2

            possible_match_scores.append(match_score)

        choose_idx = np.argmin(possible_match_scores)
        copy_pos = possible_match_positions[choose_idx]
        copy_actions = [f'{SpecialSymbols.COPY}({x})' if x is not None else act
                        for x, act in zip(copy_pos, string_actions)]

        return copy_actions, copy_pos

    @classmethod
    def get_src_copy_strings_recursive(cls, src_tokens, string_actions: List[str]) -> Tuple[List[str], List[int]]:
        """Get the copy with src pointer actions to find the match of a span of tokens. When there is
        no exact match of the whole span, find the match with the maximum number of matches and tighter
        matched positions for the span.

        NOTE when the span is a single token, the returned match is the fist one following the src tokens.
             This recursive function could be slow. For example, for smcalflow 2.0 training data, it takes 30 mins.

        Args:
            src_tokens ([type]): [description]
            string_actions (List[str]): [description]

        Returns:
            Tuple[List[str], List[int]]: [description]
        """
        assert string_actions, 'input "string_actions" should not be an empty list or None'
        assert isinstance(string_actions, list), 'input "string_actions" must be a list'
        string_len = len(string_actions)
        for i in range(len(src_tokens) - string_len):
            if string_actions == src_tokens[i:(i + string_len)]:
                # span matched, return the COPY actions with src pointers
                # copy positions
                copy_pos = list(range(i, i + string_len))
                copy_actions = [f'{SpecialSymbols.COPY}({x})' for x in copy_pos]
                return copy_actions, copy_pos

        # not finding the whole span match
        if string_len == 1:
            # single token, no match -> return as is
            return string_actions, [None]
        elif string_len == 2:
            # two tokens, no match -> match each individual one
            matched_idxs0 = cls.find_matched_positions(src_tokens, string_actions[0])
            matched_idxs1 = cls.find_matched_positions(src_tokens, string_actions[1])
            if matched_idxs0:
                if matched_idxs1:
                    # both have match -> choose the pair most close in positions
                    idxs01 = list(product(matched_idxs0, matched_idxs1))
                    idxs01_scores = [(b - a)**2 for a, b in idxs01]
                    choose_idx = np.argmin(idxs01_scores)
                    idx0, idx1 = idxs01[choose_idx]
                    copy_actions = [f'{SpecialSymbols.COPY}({idx0})', f'{SpecialSymbols.COPY}({idx1})']
                    copy_pos = [idx0, idx1]
                else:
                    # bias towards the last match
                    copy_actions = [f'{SpecialSymbols.COPY}({matched_idxs0[-1]})', string_actions[1]]
                    copy_pos = [matched_idxs0[-1], None]
            else:
                if matched_idxs1:
                    # bias towards the last match
                    copy_actions = [string_actions[0], f'{SpecialSymbols.COPY}({matched_idxs1[-1]})']
                    copy_pos = [None, matched_idxs1[-1]]
                else:
                    # neither has a match
                    copy_actions = string_actions
                    copy_pos = [None, None]
            return copy_actions, copy_pos
        else:
            copy_actions_list = []
            copy_pos_list = []
            copy_scores_list = []
            # check all the substrings by singling out one string token
            for i in range(string_len):
                # get the copy positions for previous segment
                if i == 0:
                    copy_actions_pre = []
                    copy_pos_pre = []
                else:
                    copy_actions_pre, copy_pos_pre = cls.get_src_copy_strings(src_tokens, string_actions[:i])
                # get the copy positions for the post segment
                if i == string_len - 1:
                    copy_actions_post = []
                    copy_pos_post = []
                else:
                    copy_actions_post, copy_pos_post = cls.get_src_copy_strings(src_tokens, string_actions[(i + 1):])
                # get the copy positions for the current action
                matched_idxs = cls.find_matched_positions(src_tokens, string_actions[i])
                if not len(matched_idxs):
                    # not any match
                    copy_actions_cur = [string_actions[i]]
                    copy_pos_cur = [None]
                else:
                    if len(matched_idxs) == 1:
                        # a single match
                        copy_actions_cur = [f'{SpecialSymbols.COPY}({matched_idxs[0]})']
                        copy_pos_cur = matched_idxs
                    else:
                        # more than a single matched position
                        # extract the max matched pos of the previous segment
                        if all_pos_pre := list(filter(lambda x: x is not None, copy_pos_pre)):
                            max_pos_pre = max(all_pos_pre)
                        else:
                            max_pos_pre = -1    # to be smaller than any position index
                        # extract the min matched pos of the post segment
                        if all_pos_post := list(filter(lambda x: x is not None, copy_pos_pre)):
                            min_pos_post = min(all_pos_post)
                        else:
                            min_pos_post = len(src_tokens)    # to be larger than any position index
                        # want to find a match that is in between (to keep the montonicity)
                        for idx in matched_idxs:
                            if max_pos_pre < idx < min_pos_post:
                                copy_actions_cur = [f'{SpecialSymbols.COPY}({idx})']
                                copy_pos_cur = [idx]
                                break
                        else:
                            # # bias towards the last match
                            # copy_actions_cur = [[f'{SpecialSymbols.COPY}({matched_idxs[-1]})']]
                            # copy_pos_cur = [matched_idxs[-1]]
                            # no matched index in between to keep the span match monotonic -> do not match anything
                            copy_actions_cur = [string_actions[i]]
                            copy_pos_cur = [None]
                # get the current optimal copy positions for the current segment (:i-1, i, i+1:)
                copy_actions = copy_actions_pre + copy_actions_cur + copy_actions_post
                copy_pos = copy_pos_pre + copy_pos_cur + copy_pos_post
                # store the found matches
                copy_actions_list.append(copy_actions)
                copy_pos_list.append(copy_pos)
                if all_pos := list(filter(lambda x: x is not None, copy_pos)):
                    copy_score = np.diff(all_pos)
                else:
                    copy_score = np.array([])
                copy_score = ((copy_score - 1)**2).mean() if copy_score.size >= 1 else float('inf')
                copy_scores_list.append(copy_score)
            # pick the one span matching with max number of matches and min average pos difference (a tighter span)
            # `len(src_tokens)**2` is larger than the max score computed as the square of the average pos difference
            # print(copy_scores_list)
            copy_scores_list = [ss - sum([1 if p is not None else 0 for p in pp]) * len(src_tokens)**2
                                for pp, ss in zip(copy_pos_list, copy_scores_list)]
            choose_idx = np.argmin(copy_scores_list)
            # print(copy_pos_list)
            # print(copy_scores_list)
            copy_actions = copy_actions_list[choose_idx]
            copy_pos = copy_pos_list[choose_idx]
            return copy_actions, copy_pos

    @classmethod
    def reform_actions_with_copy(cls, src_tokens, actions, only_string: bool = None, only_from_current_utter=True):

        # default config
        only_string = only_string or cls.copy_only_string

        # resulted actions with copying
        reformed_actions = []
        copy_src_positions = []

        # the most recent appearance of the special token marking the user utterance
        user_mark_index = len(src_tokens) - 1 - src_tokens[::-1].index(SrcSpecialStrings.SPEAKER_USER)

        # prioritize copying from the the current user utterance
        in_string = False
        string_actions = []
        for action in actions:
            if action in [SpecialSymbols.STRING_MARK, SpecialSymbols.STRING_MARK_END]:
                if not in_string:
                    # beginning of quoted string
                    assert action == SpecialSymbols.STRING_MARK
                    in_string = True
                    reformed_actions.append(action)
                    copy_src_positions.append(None)
                    continue
                else:
                    # ending of quoted string
                    assert action == SpecialSymbols.STRING_MARK_END
                    in_string = False

                    # match the current string span for src copying: prioritize copying from the current user utterance
                    _, copy_pos = cls.get_src_copy_strings(src_tokens[user_mark_index:], string_actions)
                    # correct the matched position indexes to be for the whole src sequence
                    copy_pos = [p + user_mark_index if p is not None else None for p in copy_pos]
                    copy_actions = [f'{SpecialSymbols.COPY}({p})' if p is not None else act
                                    for p, act in zip(copy_pos, string_actions)]
                    if only_from_current_utter:
                        # only copying from the current utterance
                        reformed_actions += copy_actions
                        copy_src_positions += copy_pos
                    else:
                        # also consider copying from the whole src sequence
                        copy_actions2, copy_pos2 = cls.get_src_copy_strings(src_tokens, string_actions)
                        # pick the one with more span matches
                        nmatch = sum([1 for p in copy_pos if p is not None])
                        nmatch2 = sum([1 for p in copy_pos2 if p is not None])
                        if nmatch >= nmatch2:
                            reformed_actions += copy_actions
                            copy_src_positions += copy_pos
                        else:
                            reformed_actions += copy_actions2
                            copy_src_positions += copy_pos2

                    # reset the current string span
                    string_actions = []

                    # add the ending quote back
                    reformed_actions.append(action)
                    copy_src_positions.append(None)
            else:
                if in_string:
                    # inside of a string span
                    string_actions.append(action)
                    # the copy match is postponed to the end of the whole string span
                else:
                    # other action tokens
                    if only_string:
                        # only copying strings
                        reformed_actions.append(action)
                        copy_src_positions.append(None)
                        continue
                    else:
                        # also check copying for other actions
                        # NOTE here is the first match
                        _, copy_pos = cls.get_src_copy_strings(src_tokens[user_mark_index:], [action])
                        assert len(copy_pos) == 1
                        copy_pos = [copy_pos[0] + user_mark_index if copy_pos[0] is not None else None]
                        copy_actions = [f'{SpecialSymbols.COPY}({copy_pos[0]})' if copy_pos[0] is not None else action]
                        if only_from_current_utter:
                            # only copying from the current utterance
                            reformed_actions += copy_actions
                            copy_src_positions += copy_pos
                        else:
                            # also consider copying from the whole src sequence, only if no match in current utterance
                            if copy_pos[0] is None:
                                matched_idxs = cls.find_matched_positions(src_tokens, action)
                                if matched_idxs:
                                    # prioritize closer copy with larger index
                                    copy_actions2 = [f'{SpecialSymbols.COPY}(matched_idxs[-1])']
                                    copy_pos2 = [matched_idxs[-1]]
                                    reformed_actions += copy_actions2
                                    copy_src_positions += copy_pos2
                                else:
                                    # no matched positions at all
                                    reformed_actions += copy_actions
                                    copy_src_positions += copy_pos
                            else:
                                reformed_actions += copy_actions
                                copy_src_positions += copy_pos

        assert len(reformed_actions) == len(copy_src_positions) == len(actions)

        return reformed_actions, copy_src_positions

    @classmethod
    def reform_actions_with_copy_file(
        cls,
        src_file: str,
        actions_file: str,
        out_file_pref: str = None,
        only_string: bool = None,
        only_from_current_utter: bool = True,
        tokenize: Callable = tokenize_line,
        pad: int = -1
    ):
        """Reform original actions from a file to actions with exact token copy from the source.

        Args:
            src_file (str): [description]
            actions_file (str): [description]
            only_string (bool, optional): [description]. Defaults to True.
            only_from_current_utter (bool, optional): [description]. Defaults to True.
            tokenize (Callable, optional): [description]. Defaults to tokenize_line.
            pad (int, optional): [description]. Defaults to -1.
        """
        actions_ext = os.path.splitext(actions_file)[1]
        assert actions_ext == '.actions', 'graph actions file name must end with ".actions"'
        if out_file_pref is not None:
            assert os.path.splitext(out_file_pref)[1] == '.actions', \
                '"out_file_pref" must end with ".actions" when provided'
        else:
            out_file_pref = actions_file

        num_total_copies = 0
        num_lines = 0

        with open(src_file, 'r') as f, open(actions_file, 'r') as g, \
                open(out_file_pref + '.src_copy', 'w') as hc, open(out_file_pref + '.src_pos', 'w') as hp:
            for src_line, actions_line in tqdm(zip(f, g), unit=' lines', desc='Check src copies and reform actions'):
                if not src_line.strip():
                    continue
                src_tokens = tokenize(src_line.strip())
                actions = tokenize(actions_line.strip())
                reformed_actions, copy_src_positions = cls.reform_actions_with_copy(
                    src_tokens,
                    actions,
                    only_string=only_string,
                    only_from_current_utter=only_from_current_utter
                )

                # check if the copies are correct -> recover to original and compare
                rec_actions = cls.recover_copy_with_token(src_tokens, reformed_actions)
                assert rec_actions == actions, 'Recovered actions from copying should be the same as the original ones'

                # add padding value to None copy positions for the src index
                copy_src_positions = [p if p is not None else pad for p in copy_src_positions]
                hc.write(' '.join(reformed_actions))
                hc.write('\n')
                hp.write(' '.join(map(str, copy_src_positions)))
                hp.write('\n')

                num_lines += 1
                num_total_copies += sum(1 if p != pad else 0 for p in copy_src_positions)

        num_avg_copies = num_total_copies / num_lines

        return num_avg_copies, num_total_copies, num_lines

    @classmethod
    def recover_copy_with_token(cls, src_tokens, actions):
        rec_actions = []
        for action in actions:
            if cpm := copy_regex.match(action):
                idx, = cpm.groups()
                idx = int(idx)
                rec_actions.append(src_tokens[idx])
            else:
                rec_actions.append(action)

        return rec_actions

    @classmethod
    def recover_copy_with_token_file(cls,
                                     src_file: str,
                                     actions_file: str,
                                     out_actions_file: str,
                                     tokenize: Callable = tokenize_line):
        """Recover the original actions by replacing the copy actions.

        Args:
            src_file (str): [description]
            actions_file (str): [description]
            out_actions_file (str): [description]
            tokenize (Callable, optional): [description]. Defaults to tokenize_line.

        Returns:
            [type]: [description]
        """
        assert os.path.splitext(out_actions_file)[1] == '.actions', 'graph actions file name must end with ".actions"'

        with open(src_file, 'r') as f, open(actions_file, 'r') as g, open(out_actions_file, 'w') as h:
            for src_line, actions_line in tqdm(zip(f, g), unit=' lines', desc='Recover orginal actions from copy'):
                if not src_line.strip():
                    continue
                src_tokens = tokenize(src_line.strip())
                actions = tokenize(actions_line.strip())
                rec_actions = cls.recover_copy_with_token(src_tokens, actions)

                # write to file
                h.write(' '.join(rec_actions))
                h.write('\n')

        return

    @classmethod
    def get_canonical_action(cls, action):
        """Get the canonical action form, by stripping out labels, pointers, etc."""
        # NOTE do not use this, as 'LA' would be returned directly as an edge, but it's a node name
        # if action in cls.canonical_actions:
        #     return action
        # NOTE do explicit matching
        if action.startswith(SpecialSymbols.COPY):
            # this includes both copy action with pointers and without pointers
            return 'COPY'
        return super().get_canonical_action(action)

    def get_valid_canonical_actions(self):
        """Get the valid canonical actions for the next step."""
        valid_cano_actions = super().get_valid_canonical_actions()

        # multi-step node: need to close
        if self.string_within:
            return valid_cano_actions + ['COPY']

        # copy outside of string
        if not self.copy_only_string:
            return valid_cano_actions + ['COPY']

        return valid_cano_actions

    @classmethod
    def get_actions_and_states(cls, actions, src_tokens):
        """At training time, formulate the target input and output and pointers, as well as state information at
        each step used by the model.
        Running stateless (vs. at decoding time, it's stateful).

        NOTE the input actions are assumed to be already WITH COPY actions.

        Args:
            actions (List[str]): actions with src copying (including src pointer); arc actions must include pointer values.
            src_tokens(List[str]): source tokens (to be referred by copy actions).
        """
        machine = cls()

        # default config
        tgt_input_original = cls.tgt_input_original

        actions_nopos_in = []
        actions_nopos_out = []
        actions_pos = []
        actions_src_pos = []
        allowed_cano_actions = []
        for i, action in enumerate(actions):
            # peel the target side pointer and the source side pointer
            act, pos, src_pos = peel_edge_and_copy_pointer(action, pad=-1)

            actions_nopos_out.append(act)
            if not tgt_input_original:
                actions_nopos_in.append(act)
            else:
                # target input side: the original string token instead of the COPY action
                actions_nopos_in.append(src_tokens[src_pos] if src_pos != -1 else act)

            # pointer of the target side for edges
            actions_pos.append(pos)
            # pointer on the source side for copying
            actions_src_pos.append(src_pos)

            # get the allowed canonical actions
            act_allowed = machine.get_valid_canonical_actions()
            allowed_cano_actions.append(act_allowed)

            cano_act = machine.get_canonical_action(action)
            # if cano_act not in act_allowed:
            #     print('\n')
            #     print(cano_act)
            #     print(act_allowed)
            #     breakpoint()
            # assert cano_act in act_allowed, 'current action not in the allowed space? check the rules.'

            # NOTE special treatment for TreeDST data where there is an empty string: <str> </str>,
            # which violate the state machine rules
            if cano_act not in act_allowed and cano_act == 'NODE_SEP_END':
                # add that to the allowed list for empty string
                allowed_cano_actions[-1] = allowed_cano_actions[-1] + [cano_act]

            # recover the original action from copy before applying
            machine.apply_action(action if src_pos == -1 else src_tokens[src_pos])

        actions_nodemask = machine.get_actions_nodemask()

        return {'actions_nopos_in': actions_nopos_in,
                'actions_nopos_out': actions_nopos_out,
                'actions_pos': actions_pos,
                'actions_src_pos': actions_src_pos,
                # general states
                'allowed_cano_actions': allowed_cano_actions,
                'actions_nodemask': actions_nodemask
                }

    def apply_action_and_update_states(self, action_nopos, action_pos, action_src_pos):
        """At decoding time, apply an action decoded by model (action without pointer + the decoded pointer value), and
        update the state information so far to be used for next step decoding.
        To then get the states, use `self.get_states()`.

        Args:
            action_nopos (str): action decoded as direct model output (mapped to str by model dictionary)
            action_pos (int): pointer value decoded by model
            actions_src_pos (int): src pointer value
        """
        self.actions_nopos_out.append(action_nopos)    # non-shifted version
        if not self.tgt_input_original:
            # focuses on the input for next decoding step: need to be shifted
            self.actions_nopos_in.append(action_nopos)
        else:
            # target input side: the original string token instead of the COPY action
            self.actions_nopos_in.append(self.src_tokens[action_src_pos]
                                         if action_nopos.startswith(SpecialSymbols.COPY)
                                         else action_nopos)

        self.actions_pos.append(action_pos)    # non-shifted version
        self.actions_src_pos.append(action_src_pos)    # non-shifted version

        # recover from copy
        if action_nopos.startswith(SpecialSymbols.COPY):
            action_nopos = self.src_tokens[action_src_pos]
        action = join_action_pointer(action_nopos, action_pos)
        self.apply_action(action)

        # if action_pos >= 0:    # -1 is used for padding at decoding
        #     assert self.actions_nodemask[action_pos] == 1, 'pointer value must be valid to a node position'

        self.action_step += 1

        return

    def get_states(self):
        # return state info to be used to model
        states = {'actions_nopos_in': self.actions_nopos_in,
                  'actions_nopos_out': self.actions_nopos_out,
                  'actions_pos': self.actions_pos,
                  'actions_src_pos': self.actions_src_pos,
                  # general states
                  'allowed_cano_actions': self.get_valid_canonical_actions(),
                  'actions_nodemask': self.get_actions_nodemask()
                  }
        return states


def peel_copy_src_pointer(action, pad=-1):
    """Peel off the source pointer value from copy actions."""
    if cpm := copy_regex.match(action):
        src_pos = int(cpm.groups()[0])
        return (SpecialSymbols.COPY, src_pos)
    else:
        return (action, pad)


def join_copy_src_pointer(action, pos):
    """Join copy action label and source pointer value."""
    if action == SpecialSymbols.COPY:
        action_complete = f'{SpecialSymbols.COPY}({pos})'
    else:
        action_complete = action
    return action_complete


def peel_edge_and_copy_pointer(action, pad=-1):
    """Peel off both the target edge pointer and the source copy pointer."""
    act, pos = peel_pointer(action, pad=pad)
    act, src_pos = peel_copy_src_pointer(act, pad=pad)
    assert not (pos != pad and src_pos != pad), \
        f'cannot have both target edge pointer and source copy pointer for the same action {act}'
    return act, pos, src_pos


def join_edge_and_copy_pointer(action, pos, src_pos):
    action = join_copy_src_pointer(action, src_pos)
    action = join_action_pointer(action, pos)
    return action
