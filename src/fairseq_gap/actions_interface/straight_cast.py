# Copyright (c) Microsoft Corporation.
# Licensed under the MIT license.
"""An interface layer that serves in between the actions generated from the graph oracle
and the actions in the modeling:
original action sequence (from oracle) -> interface -> action sequence to be conceived by the model
                                                      (+ any state information at each token step)
action sequence generated by the model -> interface -> state information at each token step

It is inherited from the graph state machine, with possible refactoring or reformation of the
detailed actions and steps depending on the modeling.

Usage:
- At training time, the actions (input and output to the decoder) along with any state information are generated in
preprocessing.
- At decoding time, the interface runs with the model generated (possibly reformulated) action sequence, and
generate any state information on the fly.
"""
from copy import deepcopy

from calflow_parsing.calflow_machine import CalFlowMachine, peel_pointer, join_action_pointer


class CalFlowActionsInterface(CalFlowMachine):
    def __init__(self):
        super().__init__()

        # model decoding input and output
        self.actions_nopos_in = []
        self.actions_nopos_out = []
        self.actions_pos = []

        # general state information
        # see `def get_states(self)`

        # step counter
        self.action_step = 0     # model decoding step

    def __deepcopy__(self, memo):
        """
        Manual deep copy of the machine.
        """
        cls = self.__class__
        result = cls.__new__(cls)
        memo[id(self)] = result
        for k, v in self.__dict__.items():
            setattr(result, k, deepcopy(v, memo))
        return result

    @classmethod
    def get_actions_and_states(cls, actions):
        """At training time, formulate the target input and output and pointers, as well as state information at
        each step used by the model.
        Running stateless (vs. at decoding time, it's stateful).

        Args:
            actions (List[str]): original actions; arc actions must include pointer values.
            dictionary ():
        """
        machine = cls()

        actions_nopos = []
        actions_pos = []
        allowed_cano_actions = []
        for i, action in enumerate(actions):
            act, pos = peel_pointer(action, pad=-1)
            actions_nopos.append(act)
            actions_pos.append(pos)

            act_allowed = machine.get_valid_canonical_actions()
            allowed_cano_actions.append(act_allowed)

            cano_act = machine.get_canonical_action(action)
            # if cano_act not in act_allowed:
            #     print('\n')
            #     print(cano_act)
            #     print(act_allowed)
            #     breakpoint()
            assert cano_act in act_allowed, 'current action not in the allowed space? check the rules.'

            machine.apply_action(action)

        actions_nodemask = machine.get_actions_nodemask()

        return {'actions_nopos_in': actions_nopos,
                'actions_nopos_out': actions_nopos,
                'actions_pos': actions_pos,
                # general states
                'allowed_cano_actions': allowed_cano_actions,
                'actions_nodemask': actions_nodemask
                }

    def apply_action_and_update_states(self, action_nopos, action_pos):
        """At decoding time, apply an action decoded by model (action without pointer + the decoded pointer value), and
        update the state information so far to be used for next step decoding.
        To then get the states, use `self.get_states()`.

        Args:
            action_nopos (str): action decoded as direct model output (mapped to str by model dictionary)
            action_pos (int): pointer value decoded by model
        """
        self.actions_nopos_in.append(action_nopos)    # focuses on the input for next decoding step: need to be shifted
        self.actions_nopos_out.append(action_nopos)    # non-shifted version
        self.actions_pos.append(action_pos)    # non-shifted version

        action = join_action_pointer(action_nopos, action_pos)
        self.apply_action(action)

        # if action_pos >= 0:    # -1 is used for padding at decoding
        #     assert self.actions_nodemask[action_pos] == 1, 'pointer value must be valid to a node position'

        self.action_step += 1

        return

    def get_states(self):
        # return state info to be used to model
        states = {'actions_nopos_in': self.actions_nopos_in,
                  'actions_nopos_out': self.actions_nopos_out,
                  'actions_pos': self.actions_pos,
                  # general states
                  'allowed_cano_actions': self.get_valid_canonical_actions(),
                  'actions_nodemask': self.get_actions_nodemask()
                  }
        return states
